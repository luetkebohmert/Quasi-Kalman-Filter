#------------------------------------------------------------------------------
#
#       Riccati_solver_extension
#
#		This file contains the function, which solves the system of Riccati
#   differential equations generated by an affine diffusion process. 
#
#------------------------------------------------------------------------------


# The input of the function are the parameters of the dynamics of the factor process 
# under the measure P (theta_P, sigma, lambda, G, mu_P, g0, delta, c), the 
# dimension d, the vector of time for which the numerical soultion to the differential 
# equations are wished and the vector of starting values of the Riccati equations.
# This is the difference to the function Riccati_solver and allows for calculating 
# more advanced affine functions. The Riccati equations are based on Theorem 10.4 of 
# the book "Term-Structure Models" from Damir Filipovic.
# Inside the function the parameters could be converted by the function Q_dynamics.
# But if one chooses lambda = rep(0, d) the parameters of the dynamics under the measure
# P are used for defining the Riccati equations.
# The function returns a matrix. Every row contains the solution for phi and 
# psi(1) to psi(d) for a specific time in the time series tau. 
# Because a part of the differential equation could be seen as a linear differential 
# equation, we split the system and first solved the linear differential equation "explicitly". 
# But the results did not change. Therefore it is ok to keep this general formulation. 

Riccati_solver_modification <- function(theta_P, sigma, lambda, G, mu_P, g0,
                                        delta, c, d, tau, starting_values) {
  
  

  
  # initializing 
  dpsi <- rep(0, d)
  dphi <- 0 
  # tau: time sequence for which the output is wanted;
  # the first value of times must be the initial time
  tau <- c(0, tau)
  
  
  # calculate the parameters under Q
  Q.dynamics <- Q_dynamics(theta_P, sigma, lambda, G, mu_P, g0, d)
  theta_Q <- Q.dynamics[[1]]
  thetamu_Q <- Q.dynamics[[2]] # theta_Q %*% mu_Q
  
  # the affine characterization of the factor process 
  B <- - theta_Q
  if (d > 1) {
    b <- thetamu_Q
    a <- diag(g0, d)
    alpha <- array(rep(0, (d * d * d)), dim = c(d, d, d))
    for (i in (1:d)){
      alpha[, , i] <- diag(G[i, ], d)
    }
    
    trueparam=list(B = B,
                   b = b,                   
                   a = a,
                   alpha = alpha,
                   delta = delta,
                   c = c)
    
    parameters <- c(as.vector(trueparam))
    
    # the initial state values for the ODE system
    states <- "0"
    state_ini <- starting_values
    for (i in 1:d) {
      states[1] <- c("phi")
      states[i + 1] <- paste("psi", i, sep = "")
    }
    names(state_ini) <- states
    
    # Riccati equations
    Riccati <- function (tau, state, parameters) {
      with(as.list(c(state, parameters)), {
        dphi <-  (0.5 * (t(state[-1]) 
                         %*% as.matrix(a, nrow = d)
                         %*% as.matrix(state[-1], nrow = d))
                  + t(b) %*% as.matrix(state[-1], nrow = d) - c)
        for (i in (1:d)) {
          dpsi[i] <- (0.5 * (t(state[-1]) %*% as.matrix(alpha[, , i], nrow = d) %*% 
                               as.matrix(state[-1], nrow = d)) +
                        B[, i] %*% as.matrix(state[-1], nrow = d) - delta[i])
        }
        
        return( list(c(dphi, dpsi)))
      })
    }
    
    # solve the differential equations
    out = ode(state_ini, tau, Riccati, parameters)
    
    # we delete the row for tau = 0
    out <- out[-1, ]
    return(out)
  } else {
    a <- g0
    b <- thetamu_Q
    alpha <- matrix(G)
    trueparam=list(B = B,
                   b = b,                   
                   a = a,
                   alpha = alpha,
                   delta = delta,
                   c = c)
    
    parameters <- c(as.vector(trueparam))
    
    # the initial state values for the ODE system
    states <- "0"
    state_ini <- rep(0, 2)
    states[1] <- c("phi")
    states[2] <- c("psi1")
    names(state_ini) <- states
    
    
    # Riccati equations
    Riccati <- function (tau, state, parameters) {
      with(as.list(c(state, parameters)), {
        dpsi <- (0.5 * (state[-1] * alpha * state[-1])
                 + B * state[-1] - delta)
        dphi <- (0.5 * (state[-1] * a * state[-1])
                 + b * state[-1] - c)
        return( list(c(dphi, dpsi)) )
      })
      
    }
    # solve the differential equations
    out = ode(state_ini, tau, Riccati, parameters)
    # we delete the row for tau = 0
    out <- out[-1, ]
    return(out)
  }
}

#------------------------------------------------------------------------------
#
#       Riccati_solver
#
#		Sometimes we need the version without starting values.
#   
#
#------------------------------------------------------------------------------


Riccati_solver <- function(theta_P, sigma, lambda, G, mu_P, g0, delta, c, d, tau) {
  
  # initializing 
  dpsi <- rep(0, d)
  dphi <- 0 
  # tau: time sequence for which the output is wanted;
  # the first value of times must be the initial time
  tau <- c(0, tau)
  
  
  # calculate the parameters under Q
  Q.dynamics <- Q_dynamics(theta_P, sigma, lambda, G, mu_P, g0, d)
  theta_Q <- Q.dynamics[[1]]
  thetamu_Q <- Q.dynamics[[2]] # theta_Q %*% mu_Q
  
  # the affine characterization of the factor process 
  B <- - theta_Q
  if (d > 1) {
    b <- thetamu_Q
    a <- diag(g0, d)
    alpha <- array(rep(0, (d * d * d)), dim = c(d, d, d))
    for (i in (1:d)){
      alpha[, , i] <- diag(G[i, ], d)
    }
    
    trueparam=list(B = B,
                   b = b,                   
                   a = a,
                   alpha = alpha,
                   delta = delta,
                   c = c)
    
    parameters <- c(as.vector(trueparam))
    
    # the initial state values for the ODE system
    states <- "0"
    state_ini <- rep(0, (d+1))
    for (i in 1:d) {
      states[1] <- c("phi")
      states[i + 1] <- paste("psi", i, sep = "")
    }
    names(state_ini) <- states
    
    # Riccati equations
    Riccati <- function (tau, state, parameters) {
      with(as.list(c(state, parameters)), {
        dphi <-  (0.5 * (t(state[-1]) 
                         %*% as.matrix(a, nrow = d)
                         %*% as.matrix(state[-1], nrow = d))
                  + t(b) %*% as.matrix(state[-1], nrow = d) - c)
        for (i in (1:d)) {
          dpsi[i] <- (0.5 * (t(state[-1]) %*% as.matrix(alpha[, , i], nrow = d) %*% 
                               as.matrix(state[-1], nrow = d)) +
                        B[, i] %*% as.matrix(state[-1], nrow = d) - delta[i])
        }
        
        return( list(c(dphi, dpsi)))
      })
    }
    
    # solve the differential equations
    out = ode(state_ini, tau, Riccati, parameters)
    
    # we delete the row for tau = 0
    out <- out[-1, ]
    return(out)
  } else {
    a <- g0
    b <- thetamu_Q
    alpha <- matrix(G)
    trueparam=list(B = B,
                   b = b,                   
                   a = a,
                   alpha = alpha,
                   delta = delta,
                   c = c)
    
    parameters <- c(as.vector(trueparam))
    
    # the initial state values for the ODE system
    states <- "0"
    state_ini <- rep(0, 2)
    states[1] <- c("phi")
    states[2] <- c("psi1")
    names(state_ini) <- states
    
    
    # Riccati equations
    Riccati <- function (tau, state, parameters) {
      with(as.list(c(state, parameters)), {
        dpsi <- (0.5 * (state[-1] * alpha * state[-1])
                 + B * state[-1] - delta)
        dphi <- (0.5 * (state[-1] * a * state[-1])
                 + b * state[-1] - c)
        return( list(c(dphi, dpsi)) )
      })
      
    }
    # solve the differential equations
    out = ode(state_ini, tau, Riccati, parameters)
    # we delete the row for tau = 0
    out <- out[-1, ]
    return(out)
  }
}



